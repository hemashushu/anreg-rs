// Copyright (c) 2024 Hemashushu <hippospark@gmail.com>, All rights reserved.
//
// This Source Code Form is subject to the terms of
// the Mozilla Public License version 2.0 and additional exceptions,
// more details in file LICENSE, LICENSE.additional and CONTRIBUTING.

use crate::route::Route;

pub struct Instance<'a> {
    pub bytes: &'a [u8],               // the utf-8 byte stream of source text
    pub threads: Vec<Thread>,          //
    pub match_ranges: Vec<MatchRange>, //
    pub counter_stack: Vec<usize>,     //
}

pub struct Thread {
    pub start_position: usize,                       // poisition included
    pub end_position: usize,                         // position excluded
    pub line_index: usize,                           //
    pub transition_stack: Vec<TransitionStackFrame>, //
}

impl Thread {
    pub fn new(start_position: usize, end_position: usize, line_index: usize) -> Thread {
        Thread {
            start_position,
            end_position,
            line_index,
            transition_stack: vec![],
        }
    }
}

pub struct TransitionStackFrame {
    pub position: usize,           // the current position
    pub repetition_count: usize,   // for backtracking
    pub current_node_index: usize, // the current node index
    pub transition_index: usize,   // target transition index
}

impl TransitionStackFrame {
    pub fn new(
        position: usize,
        repetition_count: usize,
        current_node_index: usize,
        transition_index: usize,
    ) -> Self {
        TransitionStackFrame {
            position,
            repetition_count,
            current_node_index,
            transition_index,
        }
    }
}

// the backtracking demo
// ---------------------
//
// anchors are generated by the greedy repetitions, they
// are used for backtracking.
//
// demo:
//
// 1. normal mode
//
// start                                 end
// |====*================================| <-- cursor 0
//      ^__ position (move to right only)
//
// 2. backtracking
//
// start                                 end
// |-------------------------------------|
// |          v-- pos                    |
// |====#=#=#=*==========================| <-- cursor 0
// |    ^ ^ ^ ^                          |
// |    | | | |===*======================| <-- cursor 1
// | anchors/ ^   ^__ pos' (move to right only)
// |          |__ start' (move to left by anchor only)
// |                                     |
// |-------------------------------------|
//
// 3. return to normal mode
//
// start                                 end
// |=========*===========================| <-- cursor 0
//           ^__ position (move to right only)
//
//
// 4. backtracking within backtracking
//
// start                                 end
// |-------------------------------------|
// |            v-- pos                  |
// |======#==#==*========================| <-- cursor 0
// | anchors ^  ^            v-- pos'    |
// |            |====#===#===*===========| <-- cursor 1
// |    start'__^            ^           |
// |                         |===*=======| <-- cursor 2
// |                start''__^   ^__ pos''
// |                                     |
// |-------------------------------------|
//
// 5. return to normal mode again
//
// start                                 end
// 0                                     len
// |==================*=================| <-- cursor 0
//                    ^__ position (move to right only)

#[derive(Debug, PartialEq, Clone, Default)]
pub struct MatchRange {
    pub start: usize, // position included
    pub end: usize,   // position excluded
}

impl MatchRange {
    pub fn new(start: usize, end: usize) -> Self {
        MatchRange { start, end }
    }
}

impl<'a> Instance<'a> {
    pub fn new(s: &'a str) -> Self {
        let bytes = s.as_bytes();
        Self::from_bytes(bytes)
    }

    pub fn from_bytes(bytes: &'a [u8]) -> Self {
        Instance {
            bytes,
            threads: vec![],
            match_ranges: vec![],
            counter_stack: vec![],
        }
    }

    pub fn append_transition_stack_frames_by_node(
        &mut self,
        route: &Route,
        node_index: usize,
        position: usize,
        repetition_count: usize,
    ) {
        let transition_count = {
            let thread = self.get_current_thread_ref();
            let line_index = thread.line_index;
            let node = &route.lines[line_index].nodes[node_index];
            node.transition_items.len()
        };

        // add the index of transitions in reverse order,
        // since stack pops the last element first.
        let thread = self.get_current_thread_ref_mut();
        for transition_index in (0..transition_count).rev() {
            thread.transition_stack.push(TransitionStackFrame::new(
                position,
                repetition_count,
                node_index,
                transition_index,
            ));
        }
    }

    #[inline]
    pub fn get_current_thread_ref(&self) -> &Thread {
        self.threads.last().unwrap()
    }

    #[inline]
    pub fn get_current_thread_ref_mut(&mut self) -> &mut Thread {
        let count = self.threads.len();
        &mut self.threads[count - 1]
    }
}
